# 浏览器

## 浏览器的存储

### Cookie

#### Cookie 的来源
Cookie 的本职工作并非本地存储，而是“维持状态”
我们知道，HTTP 协议是无状态的，自身不对请求和响应之间的通信状态进行保存


举个简单的例子
用户浏览了几个页面，下单了一盒饼干两盘游戏，最后结账时
由于 HTTP 是无状态的，服务器不知道用户到底下单了什么


于是 cookie 诞生了，服务器可以设置或读取 Cookies 中的信息，来维护用户跟服务器之间的状态


我们就把 cookie 理解成存储在浏览器里的一个小小的文本文件
它依附在 HTTP 请求上，在服务器与浏览器间飞来飞去
它携带着用户的相关信息，当服务器检查 cookie 时，就可以获取客户端状态

#### 那什么时候使用 cookie 呢？
这里说几个典型的场景：
- 记住密码，下次自动登录
- 购物车功能
- 记录用户浏览数据，进行商品（广告）推广

> 思考：cookie 是在哪里生产的？起到了什么作用？<br>
cookie 是网站为了辨别用户身份来存储在用户浏览器上的数据， 由服务端生成，放在客户端进行维护


#### 生成 cookie 的方式
- ##### 响应头里 Set-Cookie 存储
```js
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;  
//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）
```
*注意了，这个过期时间，读取的是客户端的时间，而不是服务端*

- ##### js 通过 document.cookie 来读写
```js
document.cookie='age=20;domain=.baidu.com'
```
此处，我们设置了 domain，意味着只有结尾为 baidu.com 的域名可以读取这条 cookie


#### Cookie 的缺点有什么？

- ##### Cookie 很小
它的大小只有 4KB，如果存储的数据多，这是完全不够用的
而且，在某些网站，对 cookie 的个数也是有限制的


- ##### 过多的 Cookie 带来巨大性能浪费
Cookie 是紧跟域名的，同一域名下的所有请求，都会携带 cookie
Cookie 虽然小，但是请求可以有很多，随着请求的叠加，带来的服务器开销是可怕的

- ##### HTTP 中不安全
HTTP 请求中 Cookie 是明文传输的，除非你使用 HTTPS

> 思考：Cookie 到底带来了哪些好处？它的优缺点又是什么？

<br>

HTML5 中增加了新的解决方案——Web Storage
它又分为 sessionStorage 和 localStorage  
有了 Web Storage，以后 cookie 只需要作为客户端和服务端的通道，保证客户端状态就行了

### LocalStorage

#### 它有什么优点

- 保存的数据可以长期存在
下一次访问网站，网站可以直接读取以前保存的信息
- 大小提升，现在大小可以达到 5M 左右
- 仅在客户端使用，不与服务端通信
- 接口封装好

> 思考：这些好处带来的变化是什么？

localstorage 作为浏览器本地存储，可以在下次访问网页时  
直接读取一些不变的信息，这样可以提升首屏渲染速度，提升用户体验

#### LocalStorage 的使用场景？
理论上键值对存储数据的任务，都可以交给它来完成  
通常我们网站更倾向于来存储一些稳定的资源，比如图片内容丰富的网站可以存储 Base64 格式图片


### SessionStorage
保存的数据只用于一次浏览器会话  
当会话结束，数据就会被清空


值得注意的是
即便你打开了同个网站下的两个不同页面，只要不是同一个浏览器  
它们的 sessionstorage 也是无法共享的


这个很好理解，你使用不同浏览器登录同一个网站  
那么你的 local 和 session 都不能共享数据


不同的是，不同标签页都不可以共享 sessionstorage  
但是同一个浏览器的不同标签页，是可以共享 localstorage 的



::: tip 总结它们之间的区别

- 共同点：都存储在浏览器端，同源策略
- 不同的：作用域不同，生命周期不同
:::

<br>

##### 怎么理解作用域呢？

localStorage 只要在相同协议下、相同主机名、相同端口下同一浏览器，就能读取同一份数据
sessionStorage 要更严格一些，必须还要在同一窗口下（同一标签页）

<br>

##### 怎么理解生命周期呢？

localStorage 持久化存储，永远不会过期，想删除，手动删除是唯一的办法  
sessionStorage 临时性存储，页面关闭，数据也就清除了

> 思考：它们之间到底有什么不同？
不同浏览器和不同标签页它们的使用区别又在哪里？

### IndexedDB

它们存储的数据再多，也就 5M 极限了，那如果我数据特别庞大怎么办呢？  
IndexedDB 出现了！


IndexedDB 是一种低级 API，用于客户端存储大量结构化数据，有多大呢？  
存储没有上限，理论上不少于 250M


不仅存量极大，它还有个好处，就是异步  
操作时它并不会锁死浏览器，用户还可以进行其他操作
而 localstorage，它只能是同步的，如果数据过大的读写，会拖慢网页

::: tip 现在我们总结一下这些浏览器的存储
- Cookie 的本职工作并非本地存储，而是“维持状态”
- Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信
- IndexedDB 用于客户端存储大量结构化数据
:::


<!-- :::tip
这是一个提示
:::

::: warning
这是一个警告
:::

::: danger
这是一个危险警告
:::

::: details
这是一个危险警告
::: -->

## 恶意脚本攻击

::: tip 考察点
XSS 攻击和 CSRF 攻击
:::

### XSS (Cross Site Script) 跨站脚本攻击

#### 常见的注入方式

#### 如何防范 XSS 的攻击



## 服务器渲染页面过程

### 渲染过程

::: tip 从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：
- DNS 查询
- TCP 连接
- HTTP 请求即响应
- 服务器响应
- 客户端渲染
:::

而这最后一步客户端渲染，又可以分为以下五个步骤：

- 处理 HTML 标记并构建 DOM 树。
- 处理 CSS 标记并构建 CSSOM 树。
- 将 DOM 与 CSSOM 合并成一个渲染树。
- 根据渲染树来布局，以计算每个节点的几何信息。
- 将各个节点绘制到屏幕上。


*需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。  
实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。*

### 阻塞渲染

谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。  
例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。

同时还要注意：

- 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。
- JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性

<br>

存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建

- 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行
- JavaScript 可以查询和修改 DOM 与 CSSOM
- CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪

**所以，script 标签的位置很重要**

::: warning 实际开发中，我们应该遵循下面两条：
- CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源
- JavaScript 应尽量少影响 DOM 的构建
:::




#### CSS 阻塞

```html
<style> p { color: red; }</style>
<link rel="stylesheet" href="index.css">
```

这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源  
浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕


#### JavaScript 阻塞

JavaScript 的情况比 CSS 要更复杂一些

```js
<p>为了卡兹莫丹！</p>
<script>console.log("inline")</script>
<p>为了暴风城！！</p>
<script src="app.js"></script>
<p>为了希尔瓦娜斯的荣耀！</p>
```
这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script  
上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打断一次（加载并且执行的时间段内）